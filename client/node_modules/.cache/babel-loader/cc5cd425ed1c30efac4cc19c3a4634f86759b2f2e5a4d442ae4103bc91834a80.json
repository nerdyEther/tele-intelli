{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\nimport { useSpriteLoader } from './useSpriteLoader.js';\nconst context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\nconst geometry = new THREE.PlaneGeometry(1, 1);\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef(({\n  startFrame,\n  endFrame,\n  fps,\n  frameName,\n  textureDataURL,\n  textureImageURL,\n  loop,\n  numberOfFrames,\n  autoPlay,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause,\n  flipX,\n  alphaTest,\n  children,\n  asSprite,\n  offset,\n  playBackwards,\n  resetOnEnd,\n  maxItems,\n  instanceItems,\n  spriteDataset,\n  canvasRenderingContext2DSettings,\n  roundFramePosition = false,\n  meshProps = {},\n  ...props\n}, fref) => {\n  var _props$scale;\n  const ref = React.useRef();\n  const spriteData = React.useRef(null);\n  const matRef = React.useRef();\n  const spriteRef = React.useRef();\n  const timerOffset = React.useRef(window.performance.now());\n  const currentFrame = React.useRef(startFrame || 0);\n  const currentFrameName = React.useRef(frameName || '');\n  const fpsInterval = (fps !== null && fps !== void 0 ? fps : 30) > 0 ? 1000 / (fps || 30) : 0;\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState([1, 1, 1]);\n  const flipOffset = flipX ? -1 : 1;\n  const [displayAsSprite, setDisplayAsSprite] = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  const pauseRef = React.useRef(pause);\n  const pos = React.useRef(offset);\n  const softEnd = React.useRef(false);\n  const frameBuffer = React.useRef([]);\n  const {\n    spriteObj,\n    loadJsonAndTexture\n  } = useSpriteLoader(null, null, animationNames, numberOfFrames, undefined, canvasRenderingContext2DSettings);\n  //\n\n  function reset() {}\n  const state = React.useMemo(() => ({\n    current: pos.current,\n    offset: pos.current,\n    imageUrl: textureImageURL,\n    reset: reset,\n    hasEnded: false,\n    ref: fref\n  }), [textureImageURL, spriteDataset]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    pos.current = offset;\n  }, [offset]);\n  const calculateAspectRatio = (width, height) => {\n    const aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (spriteDataset) {\n      var _spriteDataset$sprite;\n      parseSpriteDataLite(spriteDataset == null || (_spriteDataset$sprite = spriteDataset.spriteTexture) == null ? void 0 : _spriteDataset$sprite.clone(), spriteDataset.spriteData);\n    } else {\n      if (textureImageURL && textureDataURL) {\n        loadJsonAndTexture(textureImageURL, textureDataURL);\n      }\n    }\n  }, [spriteDataset]);\n  React.useEffect(() => {\n    if (spriteObj) {\n      var _spriteObj$spriteText;\n      parseSpriteDataLite(spriteObj == null || (_spriteObj$spriteText = spriteObj.spriteTexture) == null ? void 0 : _spriteObj$spriteText.clone(), spriteObj == null ? void 0 : spriteObj.spriteData);\n    }\n  }, [spriteObj]);\n  React.useEffect(() => {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n\n  // support backwards play\n  React.useEffect(() => {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      currentFrame.current = spriteData.current.frames.length - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useLayoutEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      if (fpsInterval <= 0) {\n        currentFrame.current = endFrame || startFrame || 0;\n      }\n      // modifySpritePosition()\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstItem(spriteData.current.frames).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName, fpsInterval]);\n\n  // lite version for pre-loaded assets\n  const parseSpriteDataLite = (textureData, frameData = null) => {\n    if (frameData === null) {\n      if (numberOfFrames) {\n        //get size from texture\n        const width = textureData.image.width;\n        const height = textureData.image.height;\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        spriteData.current.frames = frameData;\n      }\n    } else {\n      spriteData.current = frameData;\n      totalFrames.current = spriteData.current.frames.length;\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      const {\n        w,\n        h\n      } = getFirstItem(spriteData.current.frames).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = textureData;\n      }\n    }\n\n    // buffer for instanced\n    if (instanceItems) {\n      for (var i = 0; i < instanceItems.length; i++) {\n        const keys = Object.keys(spriteData.current.frames);\n        const randomKey = keys[Math.floor(Math.random() * keys.length)];\n        frameBuffer.current.push({\n          key: i,\n          frames: spriteData.current.frames,\n          selectedFrame: randomKey,\n          offset: {\n            x: 0,\n            y: 0\n          }\n        });\n      }\n    }\n    setSpriteTexture(textureData);\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = () => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    if (onStart) {\n      onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n  };\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    //if (!frameName) return\n\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstItem(frames).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n    if (fpsInterval <= 0) {\n      currentFrame.current = endFrame || startFrame || 0;\n      calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n      return;\n    }\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    if (diff <= fpsInterval) return;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        state.hasEnded = resetOnEnd ? false : true;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    const targetFrame = currentFrame.current;\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = roundFramePosition ? Math.round((metaInfo.w - 1) / frameW) : (metaInfo.w - 1) / frameW;\n    const framesV = roundFramePosition ? Math.round((metaInfo.h - 1) / frameH) : (metaInfo.h - 1) / frameH;\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[targetFrame];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      let frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        frameIndex = 0; //fallback\n      }\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  const getFirstItem = param => {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      const keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  function multiplyScale(initialScale, newScale) {\n    let _newScale = [];\n\n    // If newScale is a single number, convert it to a Vector3\n    if (typeof newScale === 'number') {\n      _newScale = [newScale, newScale, newScale];\n    } else if (Array.isArray(newScale)) {\n      // If newScale is an array, convert it to a Vector3\n      _newScale = newScale;\n    } else if (newScale instanceof THREE.Vector3) {\n      _newScale = [newScale.x, newScale.y, newScale.z];\n    }\n\n    // Multiply the scale values element-wise\n    const result = initialScale.map((value, index) => value * _newScale[index]);\n    // Convert the result to an array of numbers\n    return result;\n  }\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref,\n    scale: multiplyScale(aspect !== null && aspect !== void 0 ? aspect : [1, 1, 1], (_props$scale = props.scale) !== null && _props$scale !== void 0 ? _props$scale : 1.0)\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", _extends({\n    ref: spriteRef,\n    scale: 1.0,\n    geometry: geometry\n  }, meshProps), /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(Instances, _extends({\n    geometry: geometry,\n    limit: maxItems !== null && maxItems !== void 0 ? maxItems : 1\n  }, meshProps), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map((item, index) => /*#__PURE__*/React.createElement(Instance, _extends({\n    key: index,\n    ref: (instanceItems == null ? void 0 : instanceItems.length) === 1 ? spriteRef : null,\n    position: item,\n    scale: 1.0\n  }, meshProps))))), children));\n});\nexport { SpriteAnimator, useSpriteAnimator };","map":{"version":3,"names":["_extends","React","useFrame","THREE","Instances","Instance","useSpriteLoader","context","createContext","useSpriteAnimator","useContext","geometry","PlaneGeometry","SpriteAnimator","forwardRef","startFrame","endFrame","fps","frameName","textureDataURL","textureImageURL","loop","numberOfFrames","autoPlay","animationNames","onStart","onEnd","onLoopEnd","onFrame","play","pause","flipX","alphaTest","children","asSprite","offset","playBackwards","resetOnEnd","maxItems","instanceItems","spriteDataset","canvasRenderingContext2DSettings","roundFramePosition","meshProps","props","fref","_props$scale","ref","useRef","spriteData","matRef","spriteRef","timerOffset","window","performance","now","currentFrame","currentFrameName","fpsInterval","spriteTexture","setSpriteTexture","useState","Texture","totalFrames","aspect","setAspect","flipOffset","displayAsSprite","setDisplayAsSprite","pauseRef","pos","softEnd","frameBuffer","spriteObj","loadJsonAndTexture","undefined","reset","state","useMemo","current","imageUrl","hasEnded","useImperativeHandle","useLayoutEffect","calculateAspectRatio","width","height","aspectRatio","scale","set","useEffect","_spriteDataset$sprite","parseSpriteDataLite","clone","_spriteObj$spriteText","frames","length","modifySpritePosition","w","h","getFirstItem","sourceSize","_aspect","textureData","frameData","image","meta","version","size","map","i","keys","Object","randomKey","Math","floor","random","push","key","selectedFrame","x","y","metaInfo","frameW","frameH","Array","isArray","wrapS","wrapT","RepeatWrapping","center","repeat","framesV","frameOffsetY","runAnimation","spriteFrames","_endFrame","_offset","calculateFinalPosition","diff","endCondition","onStartCondition","manualProgressEndCondition","targetFrame","finalValX","finalValY","framesH","round","frame","frameX","frameY","originalSizeX","originalSizeY","frameOffsetX","abs","frameIndex","max","min","isNaN","_state","_delta","_spriteData$current","_matRef$current","param","multiplyScale","initialScale","newScale","_newScale","Vector3","z","result","value","index","createElement","Provider","Suspense","fallback","premultipliedAlpha","toneMapped","transparent","limit","side","DoubleSide","item","position"],"sources":["/Users/neelansh/PROJECTS/tele_intelli/tele-intelli/client/node_modules/@react-three/drei/core/SpriteAnimator.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\nimport { useSpriteLoader } from './useSpriteLoader.js';\n\nconst context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\nconst geometry = new THREE.PlaneGeometry(1, 1);\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef(({\n  startFrame,\n  endFrame,\n  fps,\n  frameName,\n  textureDataURL,\n  textureImageURL,\n  loop,\n  numberOfFrames,\n  autoPlay,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause,\n  flipX,\n  alphaTest,\n  children,\n  asSprite,\n  offset,\n  playBackwards,\n  resetOnEnd,\n  maxItems,\n  instanceItems,\n  spriteDataset,\n  canvasRenderingContext2DSettings,\n  roundFramePosition = false,\n  meshProps = {},\n  ...props\n}, fref) => {\n  var _props$scale;\n  const ref = React.useRef();\n  const spriteData = React.useRef(null);\n  const matRef = React.useRef();\n  const spriteRef = React.useRef();\n  const timerOffset = React.useRef(window.performance.now());\n  const currentFrame = React.useRef(startFrame || 0);\n  const currentFrameName = React.useRef(frameName || '');\n  const fpsInterval = (fps !== null && fps !== void 0 ? fps : 30) > 0 ? 1000 / (fps || 30) : 0;\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState([1, 1, 1]);\n  const flipOffset = flipX ? -1 : 1;\n  const [displayAsSprite, setDisplayAsSprite] = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  const pauseRef = React.useRef(pause);\n  const pos = React.useRef(offset);\n  const softEnd = React.useRef(false);\n  const frameBuffer = React.useRef([]);\n  const {\n    spriteObj,\n    loadJsonAndTexture\n  } = useSpriteLoader(null, null, animationNames, numberOfFrames, undefined, canvasRenderingContext2DSettings);\n  //\n\n  function reset() {}\n  const state = React.useMemo(() => ({\n    current: pos.current,\n    offset: pos.current,\n    imageUrl: textureImageURL,\n    reset: reset,\n    hasEnded: false,\n    ref: fref\n  }), [textureImageURL, spriteDataset]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    pos.current = offset;\n  }, [offset]);\n  const calculateAspectRatio = (width, height) => {\n    const aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (spriteDataset) {\n      var _spriteDataset$sprite;\n      parseSpriteDataLite(spriteDataset == null || (_spriteDataset$sprite = spriteDataset.spriteTexture) == null ? void 0 : _spriteDataset$sprite.clone(), spriteDataset.spriteData);\n    } else {\n      if (textureImageURL && textureDataURL) {\n        loadJsonAndTexture(textureImageURL, textureDataURL);\n      }\n    }\n  }, [spriteDataset]);\n  React.useEffect(() => {\n    if (spriteObj) {\n      var _spriteObj$spriteText;\n      parseSpriteDataLite(spriteObj == null || (_spriteObj$spriteText = spriteObj.spriteTexture) == null ? void 0 : _spriteObj$spriteText.clone(), spriteObj == null ? void 0 : spriteObj.spriteData);\n    }\n  }, [spriteObj]);\n  React.useEffect(() => {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n\n  // support backwards play\n  React.useEffect(() => {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      currentFrame.current = spriteData.current.frames.length - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useLayoutEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      if (fpsInterval <= 0) {\n        currentFrame.current = endFrame || startFrame || 0;\n      }\n      // modifySpritePosition()\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstItem(spriteData.current.frames).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName, fpsInterval]);\n\n  // lite version for pre-loaded assets\n  const parseSpriteDataLite = (textureData, frameData = null) => {\n    if (frameData === null) {\n      if (numberOfFrames) {\n        //get size from texture\n        const width = textureData.image.width;\n        const height = textureData.image.height;\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        spriteData.current.frames = frameData;\n      }\n    } else {\n      spriteData.current = frameData;\n      totalFrames.current = spriteData.current.frames.length;\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      const {\n        w,\n        h\n      } = getFirstItem(spriteData.current.frames).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = textureData;\n      }\n    }\n\n    // buffer for instanced\n    if (instanceItems) {\n      for (var i = 0; i < instanceItems.length; i++) {\n        const keys = Object.keys(spriteData.current.frames);\n        const randomKey = keys[Math.floor(Math.random() * keys.length)];\n        frameBuffer.current.push({\n          key: i,\n          frames: spriteData.current.frames,\n          selectedFrame: randomKey,\n          offset: {\n            x: 0,\n            y: 0\n          }\n        });\n      }\n    }\n    setSpriteTexture(textureData);\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = () => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    if (onStart) {\n      onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n  };\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    //if (!frameName) return\n\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstItem(frames).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n    if (fpsInterval <= 0) {\n      currentFrame.current = endFrame || startFrame || 0;\n      calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n      return;\n    }\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    if (diff <= fpsInterval) return;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        state.hasEnded = resetOnEnd ? false : true;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    const targetFrame = currentFrame.current;\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = roundFramePosition ? Math.round((metaInfo.w - 1) / frameW) : (metaInfo.w - 1) / frameW;\n    const framesV = roundFramePosition ? Math.round((metaInfo.h - 1) / frameH) : (metaInfo.h - 1) / frameH;\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[targetFrame];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      let frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        frameIndex = 0; //fallback\n      }\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  const getFirstItem = param => {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      const keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  function multiplyScale(initialScale, newScale) {\n    let _newScale = [];\n\n    // If newScale is a single number, convert it to a Vector3\n    if (typeof newScale === 'number') {\n      _newScale = [newScale, newScale, newScale];\n    } else if (Array.isArray(newScale)) {\n      // If newScale is an array, convert it to a Vector3\n      _newScale = newScale;\n    } else if (newScale instanceof THREE.Vector3) {\n      _newScale = [newScale.x, newScale.y, newScale.z];\n    }\n\n    // Multiply the scale values element-wise\n    const result = initialScale.map((value, index) => value * _newScale[index]);\n    // Convert the result to an array of numbers\n    return result;\n  }\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref,\n    scale: multiplyScale(aspect !== null && aspect !== void 0 ? aspect : [1, 1, 1], (_props$scale = props.scale) !== null && _props$scale !== void 0 ? _props$scale : 1.0)\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", _extends({\n    ref: spriteRef,\n    scale: 1.0,\n    geometry: geometry\n  }, meshProps), /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(Instances, _extends({\n    geometry: geometry,\n    limit: maxItems !== null && maxItems !== void 0 ? maxItems : 1\n  }, meshProps), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map((item, index) => /*#__PURE__*/React.createElement(Instance, _extends({\n    key: index,\n    ref: (instanceItems == null ? void 0 : instanceItems.length) === 1 ? spriteRef : null,\n    position: item,\n    scale: 1.0\n  }, meshProps))))), children));\n});\n\nexport { SpriteAnimator, useSpriteAnimator };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}